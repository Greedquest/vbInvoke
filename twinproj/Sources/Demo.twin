Module Logging
    Public Property Get Logger() As LogManager
        Static isInitialised As Boolean
        If Not isInitialised Then
            LogManager.Register DebugLogger.Create("CallByNameEx", TraceLevel)
            isInitialised = True
        End If
        Set Logger = LogManager
    End Property
    
    Public Function printf(ByVal mask As String, ParamArray tokens() As Variant) As String
        Dim i As Long
        For i = 0 To UBound(tokens)
            Dim escapedToken As String
            escapedToken = Replace$(tokens(i), "}", "\}") 'only need to replace closing bracket since {i\} is already invalid
            If InStr(1, mask, "{}") <> 0 Then
                'use positional mode {}
                mask = Replace$(mask, "{}", escapedToken, Count:=1)
            
            Else
                'use indexed mode {i}
                mask = Replace$(mask, "{" & i & "}", escapedToken)
            
            End If
        Next
        mask = Replace$(mask, "\}", "}")
        printf = mask
    End Function
    
    Public Sub Assert(ByVal condition As Boolean, Optional ByVal message As String, Optional ByVal customLog As LogManager)
        If Not condition Then
            With If(customLog Is Nothing, Logger, customLog)
                Dim errorInfo As String = printf("Assert failed {}", message)
                .log FatalLevel, errorInfo
                Err.Raise 5, description:=errorInfo
            End With
        End If
    End Sub
End Module

Public Class GenericCaster(Of TSource, TDest)
	Private Declare PtrSafe Function ShallowCopy Lib "msvbvm60" Alias "__vbaObjSetAddref" (ByRef Dest As Any, ByVal pSourceInterface As LongPtr) As Long
    Public Property Let Cast(ByRef Dest As TDest, ByRef Source As TSource)
        ShallowCopy Dest, ObjPtr(Source)
    End Property
End Class

''For reference here's what's in the VBA ExampleModule 
' Module ExampleModule
' 	Option Explicit

' 	Private Function Foo(ByVal bar As Long) As String
' 		Foo = "HelloWorld" & String(bar, "!")
' 	End Function

' 	Public Sub Baz()
' 		MsgBox "Hi!"
' 	End Sub

' 	Public Property Get val() As Double
' 		val = Rnd()
' 	End Property

' 	Public Property Let val(ByVal rhs As Double)
' 		Debug.Print "Ignoring val=" ; rhs
' 	End Property
' End Module

[ AppObject ]
Class DLLFunctionsObj
    Public Function GetPublicAccessor(ByVal moduleName As Variant, ByVal proj As VBProject) As Object
    	Return DllFunctions.GetPublicAccessor(moduleName, proj)
    End Function
    
    Public Function GetFullAccessor(ByVal moduleName As Variant, ByVal proj As VBProject, ByRef outPrivateTI As ITypeInfo) As Object
    	Return DllFunctions.GetFullAccessor(moduleName, proj, outPrivateTI)
    End Function
	
End Class
Module DllFunctions
	[ DllExport ]
    Public Function GetPublicAccessor(ByVal moduleName As Variant, ByVal proj As VBProject) As Object
        Logger.Log InfoLevel, printf("Invoking GetPublicAccessor on {}.{}", proj.Name, moduleName)
        Dim outPublicTI As ITypeInfo
        Dim outExtendedTL As TypeLibInfo
        Set GetPublicAccessor = StdModuleAccessor(moduleName, proj, proj.Name, outPublicTI, outExtendedTL)
        Logger.Log InfoLevel, printf("Discarding ITypeInfo @{} + ITypeLib* @{}", ObjPtr(outPublicTI), ObjPtr(outExtendedTL.ITypeLib))
    End Function
    
    [ DllExport ]
    Public Function GetFullAccessor(ByVal moduleName As Variant, ByVal proj As VBProject, ByRef outPrivateTI As ITypeInfo) As Object
        Logger.Log InfoLevel, printf("Invoking GetFullAccessor on {}.{}", proj.Name, moduleName)
        Dim outPublicTI As ITypeInfo
        Dim outExtendedTL As TypeLibInfo
        Dim baseAccessor As Object = StdModuleAccessor(moduleName, proj, proj.Name, outPublicTI, outExtendedTL)
        Logger.Log InfoLevel, printf("Got ITypeInfo @{} + ITypeLib* @{}", ObjPtr(outPublicTI), ObjPtr(outExtendedTL.ITypeLib))
        
        'HRESULT FindName(
        '  [in, out] LPOLESTR  szNameBuf,
        '  [in]      ULONG     lHashVal,
        '  [out]     ITypeInfo **ppTInfo,
        '  [out]     MEMBERID  *rgMemId,
        '  [in, out] USHORT * pcFound
        ');
        'Dim outPrivateTI As ITypeInfo
        Dim memberID As DISPID
        Dim pcFound As Integer = 1 'number of matches
        outExtendedTL.ITypeLib.FindName StrPtr(moduleName), 0, outPrivateTI, memberID, pcFound
        Logger.Log InfoLevel, printf("{} PrivateITypeInfo @{}", pcFound, ObjPtr(outPrivateTI))
        
        ' Return baseAccessor
        Dim swapClassInfo As IModuleInfo = New SwapClassEX(baseAccessor, outPrivateTI)
        Logger.Log TraceLevel, "Created swap class successfully"
        Return swapClassInfo.ExtendedModuleAccessor 'cannot return the swapclass itself as that is not overloaded
    End Function

End Module

[ COMCreatable (False) ]
Class SwapClassEX
    Implements IDispatchVB 'For the VTable swap
    Implements IModuleInfo 'Easy access to additional methods
    
    Private Declare PtrSafe Function SysReAllocString Lib "oleaut32.dll" (ByVal pBSTR As LongPtr, Optional ByVal pszStrPtr As LongPtr) As Long
    Private ReadOnly BaseAccessor As vbInvoke.IDispatch
    Private ReadOnly ExtendedTypeInfo As ITypeInfo
    
    Private Sub New(ByVal accessor As IDispatch, ByRef moduleTypeInfo As ITypeInfo)
        Logger.Log TraceLevel, "Creating SwapClass"
        Set BaseAccessor = accessor
        Dim caster As New GenericCaster(Of ITypeInfo, ITypeInfo)
        caster.Cast(ExtendedTypeInfo) = moduleTypeInfo
        Logger.Log DebugLevel, printf("Stored private ti@{}, supplied@{}", ObjPtr(ExtendedTypeInfo), ObjPtr(moduleTypeInfo))
        
        'get the vtable slots
        'See notes in proxy test for an improved approach
        'TODO also overload IDispatch for IModuleInfo if that is exposed?
        Dim asIDispVB As IDispatchVB = Me
        Dim pAsDispVBVT As LongPtr = MemLongPtr(ObjPtr(asIDispVB))
        
        Dim pInvokeVB As LongPtr = UnsignedAdd(pAsDispVBVT, IDispatchVBVTableOffset(IDispatchVBVTable.InvokeVB))
        Dim pGetIDsOfNamesVB As LongPtr = UnsignedAdd(pAsDispVBVT, IDispatchVBVTableOffset(IDispatchVBVTable.GetIDsOfNamesVB))
        Dim pInvokeOriginal As LongPtr = UnsignedAdd(pAsDispVBVT, IDispatchVBVTableOffset(IDispatchVBVTable.IDispatch.Invoke))
        Dim pGetIDsOfNamesOriginal As LongPtr = UnsignedAdd(pAsDispVBVT, IDispatchVBVTableOffset(IDispatchVBVTable.IDispatch.GetIDsOfNames))

        Dim unkInterface As IUnknown = Me
        Dim dispInterface As IDispatch = Me
        Logger.Log DebugLevel, printf("unk @{}, disp @{}, default@{}", ObjPtr(unkInterface), ObjPtr(dispInterface), ObjPtr(Me))
        Logger.Log DebugLevel, printf("IDispatchVB @{}, IDispatchVB_VT @{}", ObjPtr(asIDispVB), pAsDispVBVT)

        'swap the vtable entries
        Logger.Log TraceLevel, "About to swap the memory"
        Logger.Log DebugLevel, printf("invoke {}->{} ({}*{})", pInvokeOriginal, pInvokeVB, (pInvokeVB - pInvokeOriginal) / PTR_SIZE, PTR_SIZE)
        Logger.Log DebugLevel, printf("getIDs {}->{} ({}*{})", pGetIDsOfNamesOriginal, pGetIDsOfNamesVB, (pGetIDsOfNamesVB - pGetIDsOfNamesOriginal) / PTR_SIZE, PTR_SIZE)
        
        MemLongPtr(pGetIDsOfNamesOriginal) = MemLongPtr(pGetIDsOfNamesVB)
        MemLongPtr(pInvokeOriginal) = MemLongPtr(pInvokeVB)
        Logger.Log(DebugLevel, "Memory Swapped")
    End Sub

    Private Property Get funcs() As Dictionary
        'NOTE cached assuming you cannot modify typeinfo at all at runtime (i.e. you cannot edit a module while vba is running)
        'TODO Check if this holds True for VBComponents.Add
        Static result As Dictionary
        If result Is Nothing Then Set result = TypeInfoHelper.GetFuncDispidFromTypeInfo(ExtendedTypeInfo)
        Set funcs = result
    End Property

    Private Sub IDispatchVB_GetIDsOfNamesVB(ByVal riid As LongPtr, ByVal namesArray As LongPtr, ByVal cNames As Long, ByVal lcid As Long, ByVal dispidArray As LongPtr)
        Logger.Log TraceLevel, "IDispatchVB_GetIDsOfNamesVB"
        Dim i As Long
        For i = 0 To cNames - 1
            Dim name As String = GetStrFromPtrW(MemLongPtr(namesArray + PTR_SIZE * i))
            Logger.Log DebugLevel, printf("Checking for {}", name)
            If funcs.Exists(name) Then
                MemLong(dispidArray + PTR_SIZE * i) = CLng(funcs(name))
            Else
                MemLong(dispidArray + PTR_SIZE * i) = -1 'unrecognised
                Err.ReturnHResult = DISPGetIDsOfNamesErrors.DISP_E_UNKNOWNNAME
            End If
        Next i
    End Sub

    Private Sub IDispatchVB_InvokeVB(ByVal dispIDMember As Long, ByVal riid As LongPtr, ByVal lcid As Long, ByVal wFlags As Integer, ByVal pDispParams As LongPtr, ByVal pVarResult As LongPtr, ByVal pExcepInfo As LongPtr, ByVal puArgErr As LongPtr)
        Logger.Log DebugLevel, printf("IDispatchVB_InvokeVB dispid={}", dispIDMember)
        BaseAccessor.Invoke(dispIDMember, _
            riid, lcid, wFlags, _
            pDispParams, _
            pVarResult, pExcepInfo, puArgErr)
        Err.ReturnHResult = Err.LastHResult 'maybe not needed...        
    End Sub

    Private Property Get IModuleInfo_ExtendedITypeInfo() As IUnknown
        Return ExtendedTypeInfo
    End Property

    Private Property Get IModuleInfo_ModuleFuncInfoMap() As Dictionary
        Return funcs 'TODO clone, this is mutable
    End Property

    Private Property Get IModuleInfo_PublicOnlyModuleAccessor() As Object
        Return BaseAccessor
    End Property

    Private Property Get IModuleInfo_ExtendedModuleAccessor() As Object
        Dim dipatchInterface As IDispatchVB = Me 'need to cast me to the correct interface as only IDispatchVB is overloaded
        Return dipatchInterface
    End Property

    'Returns a copy of a null-terminated Unicode string (LPWSTR/LPCWSTR) from the given pointer
    Private Function GetStrFromPtrW(ByVal Ptr As LongPtr) As String
        SysReAllocString VarPtr(GetStrFromPtrW), Ptr
    End Function
End Class