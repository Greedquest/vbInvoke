[ InterfaceId ("00020400-0000-0000-C000-000000000046") ]
Interface IDispatch Extends IUnknown
    ' [
    '   object,
    '   uuid(00020400-0000-0000-C000-000000000046),
    '   pointer_default(unique)
    ' ]
    ' Interface IDispatch: IUnknown
    ' {
    '   typedef [unique] IDispatch *LPDISPATCH;

    '   Const DISPID DISPID_UNKNOWN     = -1;
    '   Const DISPID DISPID_VALUE       =  0;
    '   Const DISPID DISPID_PROPERTYPUT = -3;
    '   Const DISPID DISPID_NEWENUM     = -4;
    '   Const DISPID DISPID_EVALUATE    = -5;
    '   Const DISPID DISPID_CONSTRUCTOR = -6;
    '   Const DISPID DISPID_DESTRUCTOR  = -7;
    '   Const DISPID DISPID_COLLECT     = -8;

    '   HRESULT GetTypeInfoCount(
    '     [ out] UINT *pctinfo);

    '   HRESULT GetTypeInfo(
    '     [ in] UINT iTInfo,
    '     [ in] LCID lcid,
    '     [ out] ITypeInfo **ppTInfo);

    '   HRESULT GetIDsOfNames(
    '     [ in] REFIID riid,
    '     [ in, size_is(cNames)] LPOLESTR *rgszNames,
    '     [ in] UINT cNames,
    '     [ in] LCID lcid,
    '     [ out, size_is(cNames)] DISPID *rgDispId);

    '   [ local]
    '   HRESULT Invoke(
    '     [ in] DISPID dispIdMember,
    '     [ in] REFIID riid,
    '     [ in] LCID lcid,
    '     [ in] WORD wFlags,
    '     [ in, out] DISPPARAMS *pDispParams,
    '     [ out] VARIANT *pVarResult,
    '     [ out] EXCEPINFO *pExcepInfo,
    '     [ out] UINT *puArgErr);

    '   [ call_as(Invoke)]
    '   HRESULT RemoteInvoke(
    '     [ in] DISPID dispIdMember,
    '     [ in] REFIID riid,
    '     [ in] LCID lcid,
    '     [ in] DWORD dwFlags,
    '     [ in] DISPPARAMS *pDispParams,
    '     [ out] VARIANT *pVarResult,
    '     [ out] EXCEPINFO *pExcepInfo,
    '     [ out] UINT *pArgErr,
    '     [ in] UINT cVarRef,
    '     [ in, size_is(cVarRef)] UINT *rgVarRefIdx,
    '     [ in, out, size_is(cVarRef)] VARIANTARG *rgVarRef);
    ' }
    Sub GetTypeInfoCount()
    Sub GetTypeInfo()
    Sub GetIDsOfNames( _
        ByVal riid As LongPtr, _
        ByVal namesArray As LongPtr, _
        ByVal cNames As Long, _
        ByVal lcid As Long, _
        ByVal dispidArray As LongPtr)
    Sub Invoke( _
        ByVal dispIDMember As Long, _
        ByVal riid As LongPtr, _
        ByVal lcid As Long, _
        ByVal wFlags As Integer, _
        ByVal pDispParams As LongPtr, _
        ByVal pVarResult As LongPtr, _
        ByVal pExcepInfo As LongPtr, _
        ByVal puArgErr As LongPtr _
        )
        'HRESULT Invoke(
        '  [in]      DISPID     dispIdMember,
        '  [in]      REFIID     riid,
        '  [in]      LCID       lcid,
        '  [in]      WORD       wFlags,
        '  [in, out] DISPPARAMS *pDispParams,
        '  [out]     VARIANT    *pVarResult,
        '  [out]     EXCEPINFO  *pExcepInfo,
        '  [out] UINT * puArgErr
        ');
End Interface

Module TempVtables

    Public Type IUnknownVTable
        QueryInterface As LongPtr
        AddRef As LongPtr
        ReleaseRef As LongPtr
    End Type: Public IUnknownVTable As IUnknownVTable

    Public Type IDispatchVTable
        IUnknown As IUnknownVTable
        GetTypeInfoCount As LongPtr
        GetTypeInfo As LongPtr
        GetIDsOfNames As LongPtr
        Invoke As LongPtr
    End Type: Public IDispatchVTable As IDispatchVTable
    
    Public Type IDispatchVBVTable
        IDispatch As IDispatchVTable
        GetIDsOfNamesVB As LongPtr
        InvokeVB As LongPtr
    End Type: Public IDispatchVBVTable As IDispatchVBVTable

    Public Property Get IUnknownVTableOffset(ByRef member As LongPtr) As LongPtr
        IUnknownVTableOffset = VarPtr(member) - VarPtr(IUnknownVTable)
    End Property

    Public Property Get IDispatchVTableOffset(ByRef member As LongPtr) As LongPtr
        IDispatchVTableOffset = VarPtr(member) - VarPtr(IDispatchVTable)
    End Property
    
    Public Property Get IDispatchVBVTableOffset(ByRef member As LongPtr) As LongPtr
        IDispatchVBVTableOffset = VarPtr(member) - VarPtr(IDispatchVBVTable)
    End Property
End Module

[ COMCreatable (False) ]
Class SimplestSwap
    'TODO don't use IDispatchVB because then the pointer to IDispatch is wrong and we cannot overload root interface
    'NOTE if the consumer doesn't know any other interfaces of this class, they cannot leave the Object we provide
    'Except casting to IUnknown and back. 
    
	Implements IDispatchVB
    Private ReadOnly BaseAccessor As IDispatch
    
    Private Sub New(ByVal BaseAccessor As IDispatch)
        Set Me.BaseAccessor = BaseAccessor
        Dim asSwapInterface As IDispatchVB = Me
        Dim rootInterface As IDispatchVB = Me 'TODO overload IDispatch
        Dim pOverloadVTable As LongPtr = MemLongPtr(ObjPtr(asSwapInterface))
        Dim pRootVTable As LongPtr = MemLongPtr(ObjPtr(rootInterface))
        'addressof classmethod fails as it is per instance temp stub fn
        Logger.Log DebugLevel, printf("About to perform swap{0} base {1}{0} swap {2}{0} diff {3}*{4}", " - ", pRootVTable, pOverloadVTable, (pOverloadVTable - pRootVTable) / PTR_SIZE, PTR_SIZE)
        MemLongPtr(pRootVTable + PTR_SIZE * 5) = MemLongPtr(pOverloadVTable + PTR_SIZE * 7) 'getIDsOfNames
        MemLongPtr(pRootVTable + PTR_SIZE * 6) = MemLongPtr(pOverloadVTable + PTR_SIZE * 8) 'invoke
        Logger.Log TraceLevel, "VT swap complete"
    End Sub
    
    
    Public Function GetOverloadedInterface() As Object
    'TODO overload QI or use root IDispatch to avoid this function.
    'Overloading QI to divert IDispatch->IDispatchVB may break other interfaces.
    'Especially if e.g. IDispatchVB->GetITypeInfo calls QI root IDispatch - that would make an infinite loop
        Logger.Log TraceLevel, "GetOverloadedInterface"
        Dim asSwapInterface As IDispatchVB = Me
        Return asSwapInterface
    End Function

    Private Sub IDispatchVB_GetIDsOfNamesVB(ByVal riid As LongPtr, ByVal namesArray As LongPtr, ByVal cNames As Long, ByVal lcid As Long, ByVal dispidArray As LongPtr)
        Logger.Log TraceLevel, "IDispatchVB_GetIDsOfNamesVB"
        BaseAccessor.GetIDsOfNames(riid, namesArray, cNames, lcid, dispidArray)
        Err.ReturnHResult = Err.LastHResult 'maybe not needed...  
    End Sub
    
    Private Sub IDispatchVB_InvokeVB(ByVal dispIDMember As Long, ByVal riid As LongPtr, ByVal lcid As Long, ByVal wFlags As Integer, ByVal pDispParams As LongPtr, ByVal pVarResult As LongPtr, ByVal pExcepInfo As LongPtr, ByVal puArgErr As LongPtr)
        Logger.Log DebugLevel, printf("IDispatchVB_InvokeVB dispid={}", dispIDMember)
        BaseAccessor.Invoke(dispIDMember, _
            riid, lcid, wFlags, _
            pDispParams, _
            pVarResult, pExcepInfo, puArgErr)
        Err.ReturnHResult = Err.LastHResult 'maybe not needed...        
    End Sub
End Class
Public Module minrepro
    Public Sub testSimplestSwap()
        Dim baseObject As Object = New Collection
        baseObject.add "foo"
        
        'should call our swapped function!
        Dim proxyObject As Object = makeProxy(baseObject)
        Logger.Log TraceLevel, "Proxy made"
        proxyObject.add "bar"
        
        Dim item As Variant
        For Each item In baseObject
            Logger.Log InfoLevel, printf("Got a '{}'", item)
        Next
    End Sub

    [ DllExport ]
    Public Function makeProxy(ByVal baseObj As Object) As Object
        Logger.Log TraceLevel, printf("making proxy for {}", ObjPtr(baseObj))
        Dim result As SimplestSwap = New SimplestSwap(baseObj)
        Return result.GetOverloadedInterface
    End Function
    
    [ DllExport ]
    Public Sub CallMe()
    	MsgBox "Hello from tB"
    End Sub

End Module