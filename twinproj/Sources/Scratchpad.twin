[ InterfaceId ("00020400-0000-0000-C000-000000000046") ]
Interface IDispatch Extends IUnknown
    ' [
    '   object,
    '   uuid(00020400-0000-0000-C000-000000000046),
    '   pointer_default(unique)
    ' ]
    ' Interface IDispatch: IUnknown
    ' {
    '   typedef [unique] IDispatch *LPDISPATCH;

    '   Const DISPID DISPID_UNKNOWN     = -1;
    '   Const DISPID DISPID_VALUE       =  0;
    '   Const DISPID DISPID_PROPERTYPUT = -3;
    '   Const DISPID DISPID_NEWENUM     = -4;
    '   Const DISPID DISPID_EVALUATE    = -5;
    '   Const DISPID DISPID_CONSTRUCTOR = -6;
    '   Const DISPID DISPID_DESTRUCTOR  = -7;
    '   Const DISPID DISPID_COLLECT     = -8;

    '   HRESULT GetTypeInfoCount(
    '     [ out] UINT *pctinfo);

    '   HRESULT GetTypeInfo(
    '     [ in] UINT iTInfo,
    '     [ in] LCID lcid,
    '     [ out] ITypeInfo **ppTInfo);

    '   HRESULT GetIDsOfNames(
    '     [ in] REFIID riid,
    '     [ in, size_is(cNames)] LPOLESTR *rgszNames,
    '     [ in] UINT cNames,
    '     [ in] LCID lcid,
    '     [ out, size_is(cNames)] DISPID *rgDispId);

    '   [ local]
    '   HRESULT Invoke(
    '     [ in] DISPID dispIdMember,
    '     [ in] REFIID riid,
    '     [ in] LCID lcid,
    '     [ in] WORD wFlags,
    '     [ in, out] DISPPARAMS *pDispParams,
    '     [ out] VARIANT *pVarResult,
    '     [ out] EXCEPINFO *pExcepInfo,
    '     [ out] UINT *puArgErr);

    '   [ call_as(Invoke)]
    '   HRESULT RemoteInvoke(
    '     [ in] DISPID dispIdMember,
    '     [ in] REFIID riid,
    '     [ in] LCID lcid,
    '     [ in] DWORD dwFlags,
    '     [ in] DISPPARAMS *pDispParams,
    '     [ out] VARIANT *pVarResult,
    '     [ out] EXCEPINFO *pExcepInfo,
    '     [ out] UINT *pArgErr,
    '     [ in] UINT cVarRef,
    '     [ in, size_is(cVarRef)] UINT *rgVarRefIdx,
    '     [ in, out, size_is(cVarRef)] VARIANTARG *rgVarRef);
    ' }
    Sub GetTypeInfoCount()
    Sub GetTypeInfo()
    Sub GetIDsOfNames( _
        ByVal riid As LongPtr, _
        ByVal namesArray As LongPtr, _
        ByVal cNames As Long, _
        ByVal lcid As Long, _
        ByVal dispidArray As LongPtr)
    Sub Invoke( _
        ByVal dispIDMember As Long, _
        ByVal riid As LongPtr, _
        ByVal lcid As Long, _
        ByVal wFlags As Integer, _
        ByVal pDispParams As LongPtr, _
        ByVal pVarResult As LongPtr, _
        ByVal pExcepInfo As LongPtr, _
        ByVal puArgErr As LongPtr _
        )
        'HRESULT Invoke(
        '  [in]      DISPID     dispIdMember,
        '  [in]      REFIID     riid,
        '  [in]      LCID       lcid,
        '  [in]      WORD       wFlags,
        '  [in, out] DISPPARAMS *pDispParams,
        '  [out]     VARIANT    *pVarResult,
        '  [out]     EXCEPINFO  *pExcepInfo,
        '  [out] UINT * puArgErr
        ');
End Interface

Module TempVtables

    Public Type IUnknownVTable
        QueryInterface As LongPtr
        AddRef As LongPtr
        ReleaseRef As LongPtr
    End Type: Public IUnknownVTable As IUnknownVTable

    Public Type IDispatchVTable
        IUnknown As IUnknownVTable
        GetTypeInfoCount As LongPtr
        GetTypeInfo As LongPtr
        GetIDsOfNames As LongPtr
        Invoke As LongPtr
    End Type: Public IDispatchVTable As IDispatchVTable
    
    Public Type IDispatchVBVTable
        IDispatch As IDispatchVTable
        GetIDsOfNamesVB As LongPtr
        InvokeVB As LongPtr
    End Type: Public IDispatchVBVTable As IDispatchVBVTable

    Public Property Get IUnknownVTableOffset(ByRef member As LongPtr) As LongPtr
        IUnknownVTableOffset = VarPtr(member) - VarPtr(IUnknownVTable)
    End Property

    Public Property Get IDispatchVTableOffset(ByRef member As LongPtr) As LongPtr
        IDispatchVTableOffset = VarPtr(member) - VarPtr(IDispatchVTable)
    End Property
    
    Public Property Get IDispatchVBVTableOffset(ByRef member As LongPtr) As LongPtr
        IDispatchVBVTableOffset = VarPtr(member) - VarPtr(IDispatchVBVTable)
    End Property
	
End Module

Module MemoryProtection
	Public Enum VirtualProtectFlags                 'See Memory Protection constants: https://docs.microsoft.com/en-gb/windows/win32/memory/memory-protection-constants
        PAGE_EXECUTE_READWRITE = &H40
        PAGE_READONLY = &H2
        RESET_TO_PREVIOUS = -1
    End Enum
    
    Private Enum BOOL
        API_FALSE = 0
        'Use NOT (result = API_FALSE) for API_TRUE, as TRUE is just non-zero
    End Enum
    
    Private Declare PtrSafe Function VirtualProtect Lib "kernel32" (ByRef location As Any, ByVal numberOfBytes As Long, ByVal newProtectionFlags As VirtualProtectFlags, ByVal lpOldProtectionFlags As LongPtr) As BOOL

    Public Static Function ToggleMemoryProtection(ByVal address As LongPtr, ByVal numberOfBytes As Long, Optional ByVal newMemoryFlag As VirtualProtectFlags = RESET_TO_PREVIOUS) As Boolean
        Dim previousMemoryState As VirtualProtectFlags
        Dim unprotectWasNOOP As Boolean
        If newMemoryFlag = RESET_TO_PREVIOUS Then
            If unprotectWasNOOP Then
                ToggleMemoryProtection = True
            Else
                ToggleMemoryProtection = VirtualProtect(ByVal address, numberOfBytes, previousMemoryState, VarPtr(newMemoryFlag)) <> API_FALSE
            End If
        Else
            ToggleMemoryProtection = VirtualProtect(ByVal address, numberOfBytes, newMemoryFlag, VarPtr(previousMemoryState)) <> API_FALSE
            'check whether unprotecting even had an effect - if not then no need to toggle back
            unprotectWasNOOP = newMemoryFlag = previousMemoryState
        End If
    End Function


End Module


Module TestIt

    Public Function GetFancyAccessor(ByVal vbProj As VBProject, ByVal moduleName As String, Optional ByVal projectName As Variant) As Object
        Logger.Log(TraceLevel, "Called get fancy accessor")
        
        Dim project As String
        project = IIf(IsMissing(projectName), vbProj.Name, projectName)
        
        Dim moduleTypeInfo As ITypeInfo
        Dim accessor As Object
        Dim extendedTypeLib As ITypeLib
        Set accessor = StdModuleAccessor(moduleName, vbProj, project, moduleTypeInfo, extendedTypeLib)
        Logger.Log(DebugLevel, printf("Got accessor @{} base_ti@{} tl@{}", ObjPtr(accessor), ObjPtr(moduleTypeInfo), ObjPtr(extendedTypeLib)))
        
        'not sure why but not the same as moduleTypeInfo.ITypeInfo - different objects
        Dim extendedTypeInfo As IUnknown
        Set extendedTypeInfo = getITypeInfo(moduleName, ObjPtr(extendedTypeLib))
        Logger.Log(TraceLevel, printf("Got the TI @{}", ObjPtr(extendedTypeInfo)))
        
        'calling ITypeInfo::GetIDsOfNames, DispGetIDsOfNames etc. does not work
        Set GetFancyAccessor = tryMakeFancyAccessor(accessor, extendedTypeInfo).ExtendedModuleAccessor

    End Function
    
    'The IModuleInfo interface gives simplified access to the accessor IDispatch interface
    'IUnknown to keep correct type info interface (the extended one)
    Private Function tryMakeFancyAccessor(ByVal baseAccessor As IDispatch, ByVal moduleTypeInfo As IUnknown) As IModuleInfo
        Return New SwapClassEX(baseAccessor, moduleTypeInfo)
    End Function

    Private Function getITypeInfo(ByVal moduleName As String, ByVal pITypeLib As LongPtr) As IUnknown
        'HRESULT FindName(
        '  [in, out] LPOLESTR  szNameBuf,
        '  [in]      ULONG     lHashVal,
        '  [out]     ITypeInfo **ppTInfo,
        '  [out]     MEMBERID  *rgMemId,
        '  [in, out] USHORT * pcFound
        ');
        Dim hresult As hResultCode
        Dim pModuleITypeInfoArray(1 To 1) As LongPtr
        Dim memberIDArray(1 To 1) As Long
        '@Ignore IntegerDataType
        Dim pcFound As Integer 'number of matches
        pcFound = 1
        'call ITypeLib::FindName to get the module specific type info
        hresult = CallFunction( _
            pITypeLib, ITypeLibVTableOffset(ITypeLibVTable.FindName), _
            CR_HRESULT, CC_STDCALL, _
            StrPtr(moduleName), _
            0^, _
            VarPtr(pModuleITypeInfoArray(1)), _
            VarPtr(memberIDArray(1)), _
            VarPtr(pcFound))
                
        If hresult <> S_OK Then Err.Raise hresult
        Set getITypeInfo = ObjectFromObjPtr(pModuleITypeInfoArray(1))
    End Function


    ' Private Function getITypeInfo(ByVal moduleName As String, ByVal TypeLib As ITypeLib) As IUnknown
    '     Logger.Log(DebugLevel, printf("getITypeInfo for {} tl@{}", moduleName, ObjPtr(TypeLib)))
        
    '     Dim hresult As hResultCode
    '     Dim pModuleITypeInfoArray(1 To 1) As LongPtr
    '     Dim memberIDArray(1 To 1) As Long
    '     '@Ignore IntegerDataType
    '     Dim pcFound As Integer 'number of matches
    '     pcFound = 1
    '     'call ITypeLib::FindName to get the module specific type info
    '     TypeLib.FindName StrPtr(moduleName), 0, pModuleITypeInfoArray(1), memberIDArray(1), pcFound
    '     Logger.Log(DebugLevel, printf("found {}", pcFound))
    '     If pcFound <> 1 Then Err.Raise 5, "Module Not found!"
    '     Return ObjectFromObjPtr(pModuleITypeInfoArray(1))
    ' End Function
    
    Public Function ObjectFromObjPtr(ByVal Address As LongPtr) As IUnknown
        '@Ignore VariableNotAssigned: Assigned ByRef
        Dim result As IUnknown
        '@Ignore ValueRequired: False positive
        MemLongPtr(VarPtr(result)) = Address
        Set ObjectFromObjPtr = result
        '@Ignore ValueRequired: False positive
        MemLongPtr(VarPtr(result)) = 0
    End Function
   
End Module

[ COMCreatable (False) ]
Class SimplestSwap
    'TODO don't use IDispatchVB because then the pointer to IDispatch is wrong and we cannot overload root interface
    'NOTE if the consumer doesn't know any other interfaces of this class, they cannot leave the Object we provide
    'Except casting to IUnknown and back. 
    
	Implements IDispatchVB
    Private ReadOnly BaseAccessor As IDispatch
    
    Private Sub New(ByVal BaseAccessor As IDispatch)
        Set Me.BaseAccessor = BaseAccessor
        Dim asSwapInterface As IDispatchVB = Me
        Dim rootInterface As IDispatchVB = Me 'TODO overload IDispatch
        Dim pOverloadVTable As LongPtr = MemLongPtr(ObjPtr(asSwapInterface))
        Dim pRootVTable As LongPtr = MemLongPtr(ObjPtr(rootInterface))
        'addressof classmethod fails as it is per instance temp stub fn
        Logger.Log DebugLevel, printf("About to perform swap{0} base {1}{0} swap {2}{0} diff {3}*{4}", vbNewLine, pRootVTable, pOverloadVTable, (pOverloadVTable - pRootVTable) / PTR_SIZE, PTR_SIZE)
        MemLongPtr(pRootVTable + PTR_SIZE * 5) = MemLongPtr(pOverloadVTable + PTR_SIZE * 7) 'getIDsOfNames
        MemLongPtr(pRootVTable + PTR_SIZE * 6) = MemLongPtr(pOverloadVTable + PTR_SIZE * 8) 'invoke
        Logger.Log TraceLevel, "VT swap complete"
    End Sub
    
    
    Public Function GetOverloadedInterface() As Object
    'TODO overload QI or use root IDispatch to avoid this function.
    'Overloading QI to divert IDispatch->IDispatchVB may break other interfaces.
    'Especially if e.g. IDispatchVB->GetITypeInfo calls QI root IDispatch - that would make an infinite loop
        Logger.Log TraceLevel, "GetOverloadedInterface"
        Dim asSwapInterface As IDispatchVB = Me
        Return asSwapInterface
    End Function

    Private Sub IDispatchVB_GetIDsOfNamesVB(ByVal riid As LongPtr, ByVal namesArray As LongPtr, ByVal cNames As Long, ByVal lcid As Long, ByVal dispidArray As LongPtr)
        Logger.Log TraceLevel, "IDispatchVB_GetIDsOfNamesVB"
        BaseAccessor.GetIDsOfNames(riid, namesArray, cNames, lcid, dispidArray)
        Err.ReturnHResult = Err.LastHResult 'maybe not needed...  
    End Sub
    
    Private Sub IDispatchVB_InvokeVB(ByVal dispIDMember As Long, ByVal riid As LongPtr, ByVal lcid As Long, ByVal wFlags As Integer, ByVal pDispParams As LongPtr, ByVal pVarResult As LongPtr, ByVal pExcepInfo As LongPtr, ByVal puArgErr As LongPtr)
        Logger.Log DebugLevel, printf("IDispatchVB_InvokeVB dispid={}", dispIDMember)
        BaseAccessor.Invoke(dispIDMember, _
            riid, lcid, wFlags, _
            pDispParams, _
            pVarResult, pExcepInfo, puArgErr)
        Err.ReturnHResult = Err.LastHResult 'maybe not needed...        
    End Sub
End Class
Public Module minrepro
    Public Sub testSimplestSwap()
        Dim baseObject As Object = New Collection
        baseObject.add "foo"
        
        'should call our swapped function!
        Dim proxyObject As Object = makeProxy(baseObject)
        Logger.Log TraceLevel, "Proxy made"
        proxyObject.add "bar"
        
        Dim item As Variant
        For Each item In baseObject
            Logger.Log InfoLevel, printf("Got a '{}'", item)
        Next
    End Sub

    [ DllExport ]
    Public Function makeProxy(ByVal baseObj As Object) As Object
        Logger.Log TraceLevel, printf("making proxy for {}", ObjPtr(baseObj))
        Dim result As SimplestSwap = New SimplestSwap(baseObj)
        Return result.GetOverloadedInterface
    End Function
    
    [ DllExport ]
    Public Sub CallMe()
    	MsgBox "Hello from tB"
    End Sub

End Module